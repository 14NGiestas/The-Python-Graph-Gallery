"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const ansi_to_react_1 = __importDefault(require("ansi-to-react"));
const transforms_1 = require("@nteract/transforms");
const immutable_1 = require("immutable");
const richest_mime_1 = __importDefault(require("./richest-mime"));
const classPrefix = "nteract-display-area-";
class Output extends React.Component {
    shouldComponentUpdate(nextProps) {
        return (
        // NOTE: this only does a shallow comparison that mostly only works
        //       well for Immutable Outputs
        nextProps.output !== this.props.output ||
            nextProps.displayOrder !== this.props.displayOrder ||
            nextProps.transforms !== this.props.transforms ||
            nextProps.theme !== this.props.theme ||
            nextProps.models !== this.props.models ||
            nextProps.channels !== this.props.channels);
    }
    render() {
        let output = this.props.output;
        let models = this.props.models;
        // TODO: Incorporate the new output record types into both commutable and the react components that use them
        if (immutable_1.isImmutable(output)) {
            output = output.toJS();
        }
        if (immutable_1.isImmutable(models)) {
            models = models.toJS();
        }
        const outputType = output.output_type;
        switch (outputType) {
            case "execute_result":
            // We can defer to display data here, the cell number will be handled
            // separately. For reference, it is output.execution_count
            // The execution_count belongs in the component above if
            // this is a code cell
            // falls through
            case "display_data": {
                const bundle = output.data;
                const metadata = output.metadata;
                const boundMetadataChange = this.props.onMetadataChange &&
                    this.props.onMetadataChange.bind(null, this.props.index);
                return (React.createElement(richest_mime_1.default, { bundle: bundle, metadata: metadata, displayOrder: this.props.displayOrder, transforms: this.props.transforms, theme: this.props.theme, models: models, channels: this.props.channels, onMetadataChange: boundMetadataChange }));
            }
            case "stream": {
                const text = output.text;
                const name = output.name;
                switch (name) {
                    case "stdout":
                    case "stderr":
                        return (React.createElement(ansi_to_react_1.default, { linkify: false, className: classPrefix + name }, text));
                    default:
                        return null;
                }
            }
            case "error": {
                const traceback = output.traceback;
                if (!traceback) {
                    return (React.createElement(ansi_to_react_1.default, { linkify: false, className: classPrefix + "traceback" }, `${output.ename}: ${output.evalue}`));
                }
                return (React.createElement(ansi_to_react_1.default, { linkify: false, className: classPrefix + "traceback" }, traceback.join("\n")));
            }
            default:
                return null;
        }
    }
}
Output.defaultProps = {
    models: {},
    theme: "light",
    transforms: transforms_1.transforms,
    displayOrder: transforms_1.displayOrder,
    metadata: {}
};
exports.default = Output;
