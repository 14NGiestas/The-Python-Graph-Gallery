import * as common from "../common";
/**
 * Let this declare the way for well typed records for outputs
 *
 * General organization is:
 *
 *   - Declare the in-memory type
 *   - Declare the nbformat type (exactly matching nbformat.v4.schema.json)
 *   - Declare the message type (matching http://jupyter-client.readthedocs.io/en/stable/messaging.html)
 *   - Write a way to go from nbformat to our in-memory version
 *   - Write a way to go from message spec to our in-memory version
 *
 */
declare type ExecuteResultType = "execute_result";
export declare type ExecutionCount = number | null | undefined;
export declare const EXECUTE_RESULT: ExecuteResultType;
export declare type ExecuteResultOutput = {
    outputType: ExecuteResultType;
    executionCount: ExecutionCount;
    data: common.MimeBundle;
    metadata: {};
};
export declare type NbformatExecuteResult = {
    output_type: ExecuteResultType;
    execution_count: ExecutionCount;
    data: common.OnDiskMimebundle;
    metadata: {};
};
export declare type ExecuteResultMessage = {
    header: {
        msg_type: ExecuteResultType;
    };
    content: {
        execution_count: number;
        data: common.MimeBundle;
        metadata: {};
    };
};
export declare function executeResult(executeResultOutput?: Readonly<{
    executionCount?: ExecutionCount;
    data?: common.MimeBundle;
    metadata?: {};
}>): ExecuteResultOutput;
export declare namespace executeResult {
    var type: "execute_result";
    var fromNbformat: (s: NbformatExecuteResult) => ExecuteResultOutput;
    var fromJupyterMessage: (msg: ExecuteResultMessage) => ExecuteResultOutput;
}
export {};
