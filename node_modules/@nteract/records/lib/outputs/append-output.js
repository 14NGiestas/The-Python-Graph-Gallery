"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const escape_carriage_1 = require("escape-carriage");
const immer_1 = __importDefault(require("immer"));
function mutate() { }
exports.mutate = mutate;
/**
 * An output can be a stream of data that does not arrive at a single time. This
 * function handles the different types of outputs and accumulates the data
 * into a reduced output.
 *
 * @param {Object} outputs - Kernel output messages
 * @param {Object} output - Outputted to be reduced into list of outputs
 * @return {Array<Object>} updated-outputs - Outputs + Output
 */
mutate.appendOutput = function appendOutput(outputs, output) {
    const last = outputs[outputs.length - 1];
    if (output.outputType !== "stream" ||
        !last ||
        (outputs.length > 0 && last["outputType"] !== "stream")) {
        // If it's not a stream type, we just fold in the output
        outputs.push(output);
        return outputs;
    }
    const streamOutput = output;
    if (last &&
        outputs.length > 0 &&
        typeof streamOutput.name !== "undefined" &&
        last.outputType === "stream") {
        if (last.name === streamOutput.name) {
            const outputsLength = outputs.length - 1;
            if (outputs[outputsLength].outputType === "stream") {
                const lastStreamOutput = outputs[outputsLength];
                Object.assign(outputs[outputsLength], {
                    text: appendText(lastStreamOutput.text, streamOutput.text)
                });
                return outputs;
            }
        }
        const nextToLast = outputs[outputs.length - 2];
        if (nextToLast &&
            nextToLast.outputType === "stream" &&
            nextToLast["name"] === streamOutput.name) {
            const outputsLength = outputs.length - 2;
            if (outputs[outputsLength].outputType === "stream") {
                const nextToLastStreamOutput = outputs[outputsLength];
                Object.assign(outputs[outputsLength], {
                    text: appendText(nextToLastStreamOutput.text, streamOutput.text)
                });
                return outputs;
            }
        }
    }
    outputs.push(streamOutput);
    return outputs;
};
function appendText(text, streamText) {
    if (typeof streamText === "string") {
        return escape_carriage_1.escapeCarriageReturnSafe(text + streamText);
    }
    return text;
}
const appendOutput = immer_1.default(mutate.appendOutput);
exports.default = appendOutput;
