"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module commutable
 */
const immutable_1 = require("immutable");
/**
 * Map over all the mimetypes, turning them into our in-memory format.
 *
 * ```
 * {
 *  "application/json": {"a": 3, "b": 2},
 *  "text/html": ["<p>\n", "Hey\n", "</p>"],
 *  "text/plain": "Hey"
 * }
 * ```
 * to
 * ```
 * {
 *  "application/json": {"a": 3, "b": 2},
 *  "text/html": "<p>\nHey\n</p>",
 *  "text/plain": "Hey"
 * }
 * ```
 * @param mimeBundle The mime
 * @param previous
 * @param key
 */
exports.cleanMimeAtKey = (mimeBundle, previous, key) => previous.set(key, exports.cleanMimeData(key, mimeBundle[key]));
/**
 * Cleans mimedata, primarily converts an array of strings into a single string
 * joined by newlines.
 *
 * @param key The key, usually a mime type, that is associated with the mime data.
 * @param data The mime data to clean.
 *
 * @returns The cleaned mime data.
 */
exports.cleanMimeData = (key, data) => {
    // See https://github.com/jupyter/nbformat/blob/62d6eb8803616d198eaa2024604d1fe923f2a7b3/nbformat/v4/nbformat.v4.schema.json#L368
    if (exports.isJSONKey(key)) {
        // Data stays as is for JSON types
        return data;
    }
    if (typeof data === "string" || Array.isArray(data)) {
        return exports.demultiline(data);
    }
    throw new TypeError(`Data for ${key} is expected to be a string or an Array of strings`);
};
exports.createImmutableMimeBundle = (mimeBundle) => Object.keys(mimeBundle).reduce(exports.cleanMimeAtKey.bind(null, mimeBundle), immutable_1.Map());
exports.demultiline = (s) => Array.isArray(s) ? s.join("") : s;
/**
 * Split string into a list of strings delimited by newlines
 *
 * @param s The newline-delimited string that will be converted into an array of strings.
 *
 * @returns An array of strings.
 */
exports.remultiline = (s) => Array.isArray(s) ? s : s.split(/(.+?(?:\r\n|\n))/g).filter(x => x !== "");
exports.isJSONKey = (key) => /^application\/(.*\+)?json$/.test(key);
exports.makeExecuteResult = immutable_1.Record({
    output_type: "execute_result",
    execution_count: null,
    data: immutable_1.Map(),
    metadata: immutable_1.Map()
});
exports.makeDisplayData = immutable_1.Record({
    output_type: "display_data",
    data: immutable_1.Map(),
    metadata: immutable_1.Map()
});
exports.makeStreamOutput = immutable_1.Record({
    output_type: "stream",
    name: "stdout",
    text: ""
});
exports.makeErrorOutput = immutable_1.Record({
    output_type: "error",
    ename: "",
    evalue: "",
    traceback: immutable_1.List()
});
/**
 * Converts a mutable representation of an output to an immutable representation.
 *
 * @param output The mutable output that will be converted.
 *
 * @returns ImmutableOutput An immutable representation of the same output.
 */
exports.createImmutableOutput = (output) => {
    switch (output.output_type) {
        case "execute_result":
            return exports.makeExecuteResult({
                execution_count: output.execution_count,
                data: exports.createImmutableMimeBundle(output.data),
                metadata: immutable_1.fromJS(output.metadata)
            });
        case "display_data":
            return exports.makeDisplayData({
                data: exports.createImmutableMimeBundle(output.data),
                metadata: immutable_1.fromJS(output.metadata)
            });
        case "stream":
            return exports.makeStreamOutput({
                name: output.name,
                text: exports.demultiline(output.text)
            });
        case "error":
            return exports.makeErrorOutput({
                output_type: "error",
                ename: output.ename,
                evalue: output.evalue,
                // Note: this is one of the cases where the Array of strings (for
                // traceback) is part of the format, not a multiline string
                traceback: immutable_1.List(output.traceback)
            });
        default:
            throw new TypeError(`Output type ${output.output_type} not recognized`);
    }
};
