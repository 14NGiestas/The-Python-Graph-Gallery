/**
 * @module commutable
 */
import { Map as ImmutableMap, List as ImmutableList, Record, RecordOf } from "immutable";
import { ExecutionCount, JSONObject, MultiLineString } from "./primitives";
export declare type ImmutableMimeBundle = ImmutableMap<string, any>;
export declare type MimeBundle = {
    [key: string]: string | string[] | undefined;
};
/**
 * Map over all the mimetypes, turning them into our in-memory format.
 *
 * ```
 * {
 *  "application/json": {"a": 3, "b": 2},
 *  "text/html": ["<p>\n", "Hey\n", "</p>"],
 *  "text/plain": "Hey"
 * }
 * ```
 * to
 * ```
 * {
 *  "application/json": {"a": 3, "b": 2},
 *  "text/html": "<p>\nHey\n</p>",
 *  "text/plain": "Hey"
 * }
 * ```
 * @param mimeBundle The mime
 * @param previous
 * @param key
 */
export declare const cleanMimeAtKey: (mimeBundle: MimeBundle, previous: ImmutableMap<string, any>, key: string) => ImmutableMap<string, any>;
/**
 * Cleans mimedata, primarily converts an array of strings into a single string
 * joined by newlines.
 *
 * @param key The key, usually a mime type, that is associated with the mime data.
 * @param data The mime data to clean.
 *
 * @returns The cleaned mime data.
 */
export declare const cleanMimeData: (key: string, data: string | string[] | undefined) => string | string[] | undefined;
export declare const createImmutableMimeBundle: (mimeBundle: MimeBundle) => ImmutableMap<string, any>;
export declare const demultiline: (s: string | string[]) => string;
/**
 * Split string into a list of strings delimited by newlines
 *
 * @param s The newline-delimited string that will be converted into an array of strings.
 *
 * @returns An array of strings.
 */
export declare const remultiline: (s: string | string[]) => string[];
export declare const isJSONKey: (key: string) => boolean;
/** ExecuteResult Record Boilerplate */
declare type ExecuteResultParams = {
    output_type: "execute_result";
    execution_count: ExecutionCount;
    data: ImmutableMimeBundle;
    metadata?: any;
};
export declare const makeExecuteResult: Record.Factory<ExecuteResultParams>;
declare type ImmutableExecuteResult = RecordOf<ExecuteResultParams>;
/** DisplayData Record Boilerplate */
declare type DisplayDataParams = {
    output_type: "display_data";
    data: ImmutableMimeBundle;
    metadata?: any;
};
export declare const makeDisplayData: Record.Factory<DisplayDataParams>;
declare type ImmutableDisplayData = RecordOf<DisplayDataParams>;
/** StreamOutput Record Boilerplate */
declare type StreamOutputParams = {
    output_type: "stream";
    name: "stdout" | "stderr";
    text: string;
};
export declare const makeStreamOutput: Record.Factory<StreamOutputParams>;
declare type ImmutableStreamOutput = RecordOf<StreamOutputParams>;
/** ErrorOutput Record Boilerplate */
declare type ErrorOutputParams = {
    output_type: "error";
    ename: string;
    evalue: string;
    traceback: ImmutableList<string>;
};
export declare const makeErrorOutput: Record.Factory<ErrorOutputParams>;
declare type ImmutableErrorOutput = RecordOf<ErrorOutputParams>;
export declare type ImmutableOutput = ImmutableExecuteResult | ImmutableDisplayData | ImmutableStreamOutput | ImmutableErrorOutput;
/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                             Output Types
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
export interface ExecuteResult {
    output_type: "execute_result";
    execution_count: ExecutionCount;
    data: MimeBundle;
    metadata: JSONObject;
}
export interface DisplayData {
    output_type: "display_data";
    data: MimeBundle;
    metadata: JSONObject;
    transient?: JSONObject;
}
export interface StreamOutput {
    output_type: "stream";
    name: "stdout" | "stderr";
    text: MultiLineString;
}
export interface ErrorOutput {
    output_type: "error" | "pyerr";
    ename: string;
    evalue: string;
    traceback: string[];
}
export declare type Output = ExecuteResult | DisplayData | StreamOutput | ErrorOutput;
/**
 * Converts a mutable representation of an output to an immutable representation.
 *
 * @param output The mutable output that will be converted.
 *
 * @returns ImmutableOutput An immutable representation of the same output.
 */
export declare const createImmutableOutput: (output: Output) => ImmutableOutput;
export {};
