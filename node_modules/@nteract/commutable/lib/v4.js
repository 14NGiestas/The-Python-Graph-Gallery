"use strict";
/**
 * @module commutable
 */
/*
 * Functions in this module are provided for converting from Jupyter Notebook
 * Format v4 to nteract's in-memory format, affectionately referred to as
 * commutable.
 *
 * See: https://github.com/jupyter/nbformat/blob/62d6eb8803616d198eaa2024604d1fe923f2a7b3/nbformat/v4/nbformat.v4.schema.json
 *
 * The main goal here is consistency and compliance with the v4 spec. The types
 * contained in here (non Immutable ones) are constrained to the disk based
 * notebook format.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const notebook_1 = require("./notebook");
const cells_1 = require("./cells");
const outputs_1 = require("./outputs");
const structures_1 = require("./structures");
/**
 * Converts a mutable representation of metadata to an immutable representation.
 *
 * @param metadata A JSON representation of notebook metadata.
 *
 * @returns ImmutableMetadata An immutable representation of the metadata.
 */
const createImmutableMetadata = (metadata) => immutable_1.Map(metadata).map((v, k) => {
    if (k !== "tags") {
        return v;
    }
    if (Array.isArray(v)) {
        return immutable_1.Set(v);
    }
    // The notebook spec requires that this field is an Array of strings
    return immutable_1.Set();
});
const createImmutableRawCell = (cell) => cells_1.makeRawCell({
    cell_type: cell.cell_type,
    source: outputs_1.demultiline(cell.source),
    metadata: createImmutableMetadata(cell.metadata)
});
const createImmutableMarkdownCell = (cell) => cells_1.makeMarkdownCell({
    cell_type: cell.cell_type,
    source: outputs_1.demultiline(cell.source),
    metadata: createImmutableMetadata(cell.metadata)
});
const createImmutableCodeCell = (cell) => cells_1.makeCodeCell({
    cell_type: cell.cell_type,
    source: outputs_1.demultiline(cell.source),
    outputs: immutable_1.List(cell.outputs.map(outputs_1.createImmutableOutput)),
    execution_count: cell.execution_count,
    metadata: createImmutableMetadata(cell.metadata)
});
/**
 * Converts a JSON representation of a cell of any type to the correct
 * immutable representation, per the v4 nbformat specification.
 *
 * @param cell A JSON representation of a cell.
 *
 * @returns An immutable representation of the same cell.
 */
const createImmutableCell = (cell) => {
    switch (cell.cell_type) {
        case "markdown":
            return createImmutableMarkdownCell(cell);
        case "code":
            return createImmutableCodeCell(cell);
        case "raw":
            return createImmutableRawCell(cell);
        default:
            throw new TypeError(`Cell type ${cell.cell_type} unknown`);
    }
};
exports.fromJS = (notebook) => {
    if (notebook.nbformat !== 4 || notebook.nbformat_minor < 0) {
        throw new TypeError(`Notebook is not a valid v4 notebook. v4 notebooks must be of form 4.x
       It lists nbformat v${notebook.nbformat}.${notebook.nbformat_minor}`);
    }
    // Since we're doing N cell operations all at once, switch to mutable then
    // switch back after.
    const starterCellStructure = {
        cellOrder: immutable_1.List().asMutable(),
        cellMap: immutable_1.Map().asMutable()
    };
    const cellStructure = notebook.cells.reduce((cellStruct, cell) => structures_1.appendCell(cellStruct, createImmutableCell(cell)), starterCellStructure);
    return notebook_1.makeNotebookRecord({
        cellOrder: cellStructure.cellOrder.asImmutable(),
        cellMap: cellStructure.cellMap.asImmutable(),
        nbformat_minor: notebook.nbformat_minor,
        nbformat: 4,
        metadata: immutable_1.fromJS(notebook.metadata)
    });
};
const metadataToJS = (immMetadata) => immMetadata.toJS();
const mimeBundleToJS = (immMimeBundle) => {
    const bundle = immMimeBundle.toObject();
    Object.keys(bundle).map(key => {
        if (outputs_1.isJSONKey(key)) {
            if (immutable_1.Map.isMap(bundle[key])) {
                bundle[key] = bundle[key].toJS();
            }
            return bundle;
        }
        const data = bundle[key];
        if (typeof data === "string" || Array.isArray(data)) {
            bundle[key] = outputs_1.remultiline(data);
            return bundle;
        }
        throw new TypeError(`Data for ${key} is expected to be a string or an Array of strings`);
    });
    return bundle;
};
const outputToJS = (output) => {
    switch (output.output_type) {
        case "execute_result":
            return {
                output_type: output.output_type,
                execution_count: output.execution_count,
                data: mimeBundleToJS(output.data),
                metadata: output.metadata.toJS()
            };
        case "display_data":
            return {
                output_type: output.output_type,
                data: mimeBundleToJS(output.data),
                metadata: output.metadata.toJS()
            };
        case "stream":
            return {
                output_type: output.output_type,
                name: output.name,
                text: outputs_1.remultiline(output.text)
            };
        case "error":
            return {
                output_type: output.output_type,
                ename: output.ename,
                evalue: output.evalue,
                // Note: this is one of the cases where the Array of strings (for
                // traceback) is part of the format, not a multiline string
                traceback: output.traceback.toJS()
            };
    }
};
const markdownCellToJS = (immCell) => ({
    cell_type: "markdown",
    source: outputs_1.remultiline(immCell.source),
    metadata: metadataToJS(immCell.metadata)
});
/**
 * Converts an immutable representation of a code cell to a JSON representation.
 *
 * @param immCell An immutable representation of a code cell.
 *
 * @returns A JSON representation of the same code cell.
 */
const codeCellToJS = (immCell) => {
    return {
        cell_type: "code",
        source: outputs_1.remultiline(immCell.source),
        outputs: immCell.outputs.map(outputToJS).toArray(),
        execution_count: immCell.execution_count,
        metadata: metadataToJS(immCell.metadata)
    };
};
/**
 * Converts an immutable representation of a raw cell to a JSON representation.
 *
 * @param immCell An immutable representation of a raw cell.
 *
 * @returns A JSON representation of the same raw cell.
 */
const rawCellToJS = (immCell) => {
    return {
        cell_type: "raw",
        source: outputs_1.remultiline(immCell.source),
        metadata: metadataToJS(immCell.get("metadata", immutable_1.Map()))
    };
};
/**
 * Converts an immutable cell to a JSON cell.
 *
 * @param immCell An immutable representation of a cell.
 *
 * @returns A JSON representation of the same cell.
 */
const cellToJS = (immCell) => {
    switch (immCell.cell_type) {
        case "markdown":
            return markdownCellToJS(immCell);
        case "code":
            return codeCellToJS(immCell);
        case "raw":
            return rawCellToJS(immCell);
        default:
            throw new TypeError(`Cell type unknown at runtime`);
    }
};
/**
 * Converts an immutable representation of a notebook to a JSON representation.
 *
 * @param immnb The immutable representation of a notebook.
 *
 * @returns The JSON representation of a notebook.
 */
exports.toJS = (immnb) => {
    const plainNotebook = immnb.toObject();
    const plainCellOrder = plainNotebook.cellOrder.toArray();
    const plainCellMap = plainNotebook.cellMap.toObject();
    const cells = plainCellOrder.map((cellId) => cellToJS(plainCellMap[cellId]));
    return {
        cells,
        metadata: plainNotebook.metadata.toJS(),
        nbformat: 4,
        nbformat_minor: plainNotebook.nbformat_minor
    };
};
