"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module commutable
 */
const immutable_1 = require("immutable");
const notebook_1 = require("./notebook");
const cells_1 = require("./cells");
const outputs_1 = require("./outputs");
const structures_1 = require("./structures");
const VALID_MIMETYPES = {
    text: "text/plain",
    latex: "text/latex",
    png: "image/png",
    jpeg: "image/jpeg",
    svg: "image/svg+xml",
    html: "text/html",
    javascript: "application/x-javascript",
    json: "application/javascript",
    pdf: "application/pdf"
};
const createImmutableMarkdownCell = (cell) => cells_1.makeMarkdownCell({
    cell_type: cell.cell_type,
    source: outputs_1.demultiline(cell.source),
    metadata: immutable_1.fromJS(cell.metadata)
});
const createImmutableMimeBundle = (output) => {
    const mimeBundle = {};
    for (const key of Object.keys(output)) {
        // v3 had non-media types for rich media
        if (key in VALID_MIMETYPES) {
            mimeBundle[VALID_MIMETYPES[key]] =
                output[key];
        }
    }
    return Object.keys(mimeBundle).reduce(outputs_1.cleanMimeAtKey.bind(null, mimeBundle), immutable_1.Map());
};
const createImmutableOutput = (output) => {
    switch (output.output_type) {
        case "pyout":
            return outputs_1.makeExecuteResult({
                execution_count: output.prompt_number,
                // Note strangeness with v4 API
                data: createImmutableMimeBundle(output),
                metadata: immutable_1.fromJS(output.metadata)
            });
        case "display_data":
            return outputs_1.makeDisplayData({
                data: createImmutableMimeBundle(output),
                metadata: immutable_1.fromJS(output.metadata)
            });
        case "stream":
            // Default to stdout in all cases unless it's stderr
            const name = output.stream === "stderr" ? "stderr" : "stdout";
            return outputs_1.makeStreamOutput({
                name,
                text: outputs_1.demultiline(output.text)
            });
        case "pyerr":
            return outputs_1.makeErrorOutput({
                ename: output.ename,
                evalue: output.evalue,
                traceback: immutable_1.List(output.traceback)
            });
        default:
            throw new TypeError(`Output type ${output.output_type} not recognized`);
    }
};
const createImmutableCodeCell = (cell) => cells_1.makeCodeCell({
    cell_type: cell.cell_type,
    source: outputs_1.demultiline(cell.input),
    outputs: immutable_1.List(cell.outputs.map(createImmutableOutput)),
    execution_count: cell.prompt_number,
    metadata: immutable_1.fromJS(cell.metadata)
});
const createImmutableRawCell = (cell) => cells_1.makeRawCell({
    cell_type: cell.cell_type,
    source: outputs_1.demultiline(cell.source),
    metadata: immutable_1.fromJS(cell.metadata)
});
const createImmutableHeadingCell = (cell) => 
// v3 heading cells are just markdown cells in v4+
cells_1.makeMarkdownCell({
    cell_type: "markdown",
    source: Array.isArray(cell.source)
        ? outputs_1.demultiline(cell.source.map(line => Array(cell.level)
            .join("#")
            .concat(" ")
            .concat(line)))
        : cell.source,
    metadata: immutable_1.fromJS(cell.metadata)
});
const createImmutableCell = (cell) => {
    switch (cell.cell_type) {
        case "markdown":
            return createImmutableMarkdownCell(cell);
        case "code":
            return createImmutableCodeCell(cell);
        case "raw":
            return createImmutableRawCell(cell);
        case "heading":
            return createImmutableHeadingCell(cell);
        default:
            throw new TypeError(`Cell type ${cell.cell_type} unknown`);
    }
};
exports.fromJS = (notebook) => {
    if (notebook.nbformat !== 3 || notebook.nbformat_minor < 0) {
        throw new TypeError(`Notebook is not a valid v3 notebook. v3 notebooks must be of form 3.x
      It lists nbformat v${notebook.nbformat}.${notebook.nbformat_minor}`);
    }
    const starterCellStructure = {
        cellOrder: immutable_1.List().asMutable(),
        cellMap: immutable_1.Map().asMutable()
    };
    const cellStructure = [].concat.apply([], notebook.worksheets.map(worksheet => worksheet.cells.reduce((cellStruct, cell) => structures_1.appendCell(cellStruct, createImmutableCell(cell)), starterCellStructure)))[0];
    return notebook_1.makeNotebookRecord({
        cellOrder: cellStructure.cellOrder.asImmutable(),
        cellMap: cellStructure.cellMap.asImmutable(),
        nbformat_minor: notebook.nbformat_minor,
        nbformat: 4,
        metadata: immutable_1.fromJS(notebook.metadata)
    });
};
