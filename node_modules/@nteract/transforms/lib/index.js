"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const transform_vdom_1 = __importDefault(require("@nteract/transform-vdom"));
const text_1 = __importDefault(require("./text"));
const json_1 = __importDefault(require("./json"));
const javascript_1 = __importDefault(require("./javascript"));
const html_1 = __importDefault(require("./html"));
const markdown_1 = __importDefault(require("./markdown"));
const latex_1 = __importDefault(require("./latex"));
const svg_1 = __importDefault(require("./svg"));
const image_1 = require("./image");
const tfs = [
    transform_vdom_1.default,
    json_1.default,
    javascript_1.default,
    html_1.default,
    markdown_1.default,
    latex_1.default,
    svg_1.default,
    image_1.GIFDisplay,
    image_1.PNGDisplay,
    image_1.JPEGDisplay,
    text_1.default
];
exports.standardTransforms = {};
tfs.forEach(transform => {
    exports.standardTransforms[transform.MIMETYPE] = transform;
});
exports.standardDisplayOrder = tfs.map(transform => transform.MIMETYPE);
function registerTransform({ transforms, displayOrder }, transform) {
    return {
        transforms: Object.assign({}, transforms, { [transform.MIMETYPE]: transform }),
        displayOrder: [transform.MIMETYPE, ...displayOrder]
    };
}
exports.registerTransform = registerTransform;
/**
 * Choose the richest mimetype available based on the displayOrder and transforms
 * @param  {Map}   bundle - Map({mimetype1: data1, mimetype2: data2, ...})
 * @param  {Array} ordered list of mimetypes - ['text/html', 'text/plain']
 * @param  {Map}   mimetype -> React Component - Map({'text/plain': TextTransform})
 * @return {string}          Richest mimetype
 */
function richestMimetype(bundle, order = exports.standardDisplayOrder, tf = exports.standardTransforms) {
    return ([...Object.keys(bundle)]
        // we can only use those we have a transform for
        .filter(mimetype => tf[mimetype] && order.includes(mimetype))
        // the richest is based on the order in displayOrder
        .sort((a, b) => order.indexOf(a) - order.indexOf(b))[0]);
}
exports.richestMimetype = richestMimetype;
exports.transforms = exports.standardTransforms;
exports.displayOrder = exports.standardDisplayOrder;
exports.TextTransform = text_1.default;
exports.JSONTransform = json_1.default;
exports.JavaScriptTransform = javascript_1.default;
exports.HTMLTransform = html_1.default;
exports.MarkdownTransform = markdown_1.default;
exports.LaTeXTransform = latex_1.default;
exports.SVGTransform = svg_1.default;
exports.PNGTransform = image_1.PNGDisplay;
exports.JPEGTransform = image_1.JPEGDisplay;
exports.GIFTransform = image_1.GIFDisplay;
exports.VDOMTransform = transform_vdom_1.default;
